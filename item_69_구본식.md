# item69 예외는 진짜 예외 상황에만 사용하라.
## 예외의 잘못된 사용

```java
// 배열을 무한루프로 돌다가 배열 끝에 도달하면 예외 발생 코드
try{
	int i=0;
	while(true)
		range[i++].climb();
} catch (ArrayIndexOutOfBoundsException e){
}
```

사용한 이유?)
- 일반적인 반복문(for)에서 반복마다 배열의 경계를 넘는지 검사하고, JVM도 배열에 접근할 때마다 경계가 넘는지 검사하는데, 중복을 없애(첫번째 검사) 성능을 향상시키기 위해서.

But!)
- JVM이 알아서 최적화 해준다.(중복 검사 수행하지 않음)
- 표준 관용구(for-each) 보다 훨씬 느리다.(예외 사용)
- 무엇보다도 **직관적이지 않다.**
- 메서드 내에서(climb) 만약 따른 배열을 사용하다가 예외(ArrayIndexOutOfBoundsException)가 발생할 시, 정상 종료로 오해한다.

⇒ 예외를 제어 흐름용이 아닌, 진짜 예외인 상황에만 사용하라.

⇒ 과도한 성능 개선 기법 코드 보다는, 표준적인 관용구를 사용하라.

---

## 상태 검사 메서드
API 설계 시, 클라이언트가 제어 흐름에서 예외를 사용하지 않도록, `상태 의존성 메서드`를 제공하는 클래스에서는 `상태 검사 메서드`도 함께 제공하라.

### Iterator가 상태  검사 메서드를 제공하지 않았을 경우
```java
try{
	Iterator<Foo> i = collection.iterator();
	while(true)
		Foo foo = i.next();
} catch (NoSuchElementException e) {
}
```

→ 클라이언트가 hasNext 기능의 일을 대신해야 함.

→ 직관적이지 않고, 속도가 느리고, 엉뚱한 버그를 숨길 수 있다.

### Iterator가 상태  검사 메서드를 제공했기 때문에 가능한 경우
```java
for (Iterator<Foo> i = collection.iterator(); i.hasNext(); ){
}
```

---

## 또다른 방법

상태 검사 메서드 대신, 옵셔널, null 값을 반환하는 방법도 있음.

### 1) 옵셔널이나 특정 값 사용

- 동기화 없이 여러 스레드가 동시 접근 할 수 있거나, 외부 요인으로 상태가 변할 수 있는 경우
  (상태 검사 메서드와 상태 의존성 메서드 사이에 상태가 변할 수 있음 → 동시성 이슈 등)
- 성능이 중요한 상황에서, 상태 검사 메서드가  상태 의존성 메서드를 사용할 경우

### 2) 상태 검사 메서드 사용

- 1번이 아닌 경우 대부분 사용