# 인스턴스화를 막으려거든 Private 생성자를 사용하라

### 유틸리티 클래스

배열에 대한 부가 기능들을 제공하는 Arrays 아시죠?

클래스 해당 클래스를 들어가보면 이렇게 생성자가 private 으로 선언되어 있습니다.

```java
package java.util;

public class Arrays {

    // Suppresses default constructor, ensuring non-instantiability.
    private Arrays() {}
```

인스턴스화해서 쓸 이유가 없기 때문에, 해당 클래스의 인스턴스화를 막습니다.

우리는 이런 클래스들을 `유틸리티 클래스`라고 합니다.

`유틸리티 클래스`: 정적(`final`) 맴버만 담은 클래스.

### 생성자 Private의 또 다른 기능: extends 막음

모든 생성자는 상위 클래스의 생성자를 호출하게 됩니다.

-> `super()`

그래서 만약 생성자가 Private 이라면 상위 클래스 생성자에 접근할 수 없기 때문에 상속이 불가능합니다.

> 물론 Class를 final 로 선언해도 클래스 상속이 불가능합니다!


### 그런데
이런 유틸리티 용도로 클래스를 쓰는 개념이 썩 객체지향적이지는 않다.

특정 일반적으로 유틸의 대상 객체가 매서드로 제공하는 것이 적절하긴 하다.

아마 java.util 패키지 안의 클래스들처럼 너무 많은 기능이 있으면 분리하는 듯.

재사용 / 유지보수 / 리소스 절약 관점의 Trade off ~ !

gpt의 생각
>편의성과 효율성: 유틸리티 클래스들은 특정 작업을 수행하기 위한 정적 메서드들로 구성되어 있습니다. 이는 객체를 생성하고 관리하는 오버헤드를 피하면서도 간편하고 효율적인 방법으로 기능을 사용할 수 있다는 장점을 제공합니다. 예를 들어, Collections 클래스는 정적 메서드를 통해 컬렉션 관련 작업을 수행하는 메서드들을 제공합니다. 이는 객체지향적인 설계보다는 더 편리하고 효율적인 방법일 수 있습니다.
>
>일반화와 재사용: 유틸리티 클래스들은 많은 애플리케이션에서 공통적으로 사용되는 기능들을 제공합니다. 이러한 클래스들은 일반화된 방식으로 구현되어 여러 곳에서 재사용할 수 있습니다. 예를 들어, Arrays 클래스는 배열과 관련된 작업을 수행하는 메서드들을 제공합니다. 이러한 유틸리티 클래스들은 개발자들에게 중복 코드 작성을 피하고 코드의 일관성과 재사용성을 높여줍니다.
>
>성능과 메모리 사용량: 객체지향 설계는 객체 생성과 관리에 일정한 오버헤드를 가지고 있을 수 있습니다. 유틸리티 클래스는 정적 메서드를 통해 작업을 수행하므로 객체 생성에 따른 오버헤드를 피할 수 있습니다. 또한, 유틸리티 클래스는 일반적으로 메모리 상에 단일 인스턴스를 유지하기 때문에 메모리 사용량을 줄일 수 있습니다.